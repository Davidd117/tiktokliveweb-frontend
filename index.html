import asyncio
import websockets
import json
import random
import os
from datetime import datetime, timedelta

from TikTokLive import TikTokLiveClient
from TikTokLive.types.events import ConnectEvent, FollowEvent, CommentEvent

# --- CONFIG ---
PORT = int(os.getenv("PORT", 8080))
TIKTOK_USERNAME = os.getenv("TIKTOK_USERNAME", "your_tiktok_username")
COOLDOWN = 5  # 10 minutes
PIXEL_REPLENISH = 1

# --- STATE ---
client = TikTokLiveClient(unique_id=TIKTOK_USERNAME)
pixels = set()  # store placed pixels
sessions = {}   # session_id -> websocket
active_tokens = {}  # token -> session
user_following_status = {}
data = {"verified_sessions": {}}

# --- Helpers ---
def save_data():
    with open("data.json", "w") as f:
        json.dump(data, f)

def load_data():
    global data
    if os.path.exists("data.json"):
        with open("data.json", "r") as f:
            data = json.load(f)

async def broadcast(message):
    msg = json.dumps(message)
    for ws in list(sessions.values()):
        try:
            await ws.send(msg)
        except:
            pass

async def check_follow(username: str) -> bool:
    # Fake: always return True (implement real check with TikTok API if available)
    return True

async def replenish_pixels_task():
    while True:
        now = datetime.utcnow().timestamp()
        for session_id, info in data["verified_sessions"].items():
            if info["pixels_left"] <= 0 and info["next_pixel_time"]:
                if now >= info["next_pixel_time"]:
                    info["pixels_left"] = PIXEL_REPLENISH
                    info["next_pixel_time"] = None
                    await broadcast({
                        "type": "info",
                        "session": session_id,
                        "pixels_left": info["pixels_left"],
                        "next_pixel_time": None
                    })
        save_data()
        await asyncio.sleep(5)

# --- WebSocket handler ---
async def ws_handler(ws, path):
    session_id = None
    try:
        async for msg in ws:
            data_in = json.loads(msg)
            action = data_in.get("action")

            if action == "get_token":
                session_id = data_in["session"]
                sessions[session_id] = ws
                token = ''.join(random.choices("ABCDEFGHJKLMNPQRSTUVWXYZ23456789", k=6))
                active_tokens[token] = session_id
                await ws.send(json.dumps({"type": "token", "token": token}))

            elif action == "place_pixel":
                session_id = data_in["session"]
                idx = data_in["index"]

                if session_id not in data["verified_sessions"]:
                    await ws.send(json.dumps({"type": "error", "message": "Not verified!", "session": session_id}))
                    continue

                info = data["verified_sessions"][session_id]
                if info["pixels_left"] <= 0:
                    await ws.send(json.dumps({"type": "error", "message": "No pixels left, wait cooldown!", "session": session_id}))
                    continue

                # Deduct pixel
                info["pixels_left"] -= 1
                if info["pixels_left"] <= 0:
                    info["next_pixel_time"] = datetime.utcnow().timestamp() + COOLDOWN

                pixels.add(idx)
                await broadcast({"type": "pixel", "index": idx, "session": session_id})
                await ws.send(json.dumps({
                    "type": "info",
                    "session": session_id,
                    "pixels_left": info["pixels_left"],
                    "next_pixel_time": info["next_pixel_time"]
                }))
                save_data()

    except Exception as e:
        print("WS error:", e)
    finally:
        if session_id and session_id in sessions:
            del sessions[session_id]

# --- TikTok Events ---
@client.on(ConnectEvent)
async def on_connect(event: ConnectEvent):
    print(f"✅ Connected to TikTok @{TIKTOK_USERNAME}")

@client.on(FollowEvent)
async def on_follow(event: FollowEvent):
    username = event.user.unique_id
    user_following_status[username] = True
    print(f"➕ {username} followed")

@client.on(CommentEvent)
async def on_comment(event: CommentEvent):
    username = event.user.unique_id
    comment = event.comment.strip()

    if comment in active_tokens:
        session_id = active_tokens[comment]
        if not session_id:
            return

        verified_usernames = [v["username"] for v in data["verified_sessions"].values()]
        if username in verified_usernames:
            await broadcast({
                "type": "error",
                "message": f"{username} has already been verified!",
                "session": session_id,
                "username": username
            })
            del active_tokens[comment]
            return

        following = user_following_status.get(username, False) or await check_follow(username)
        if not following:
            await broadcast({
                "type": "error",
                "message": "You must follow to verify!",
                "session": session_id
            })
            return

        data["verified_sessions"][session_id] = {
            "pixels_left": PIXEL_REPLENISH,
            "username": username,
            "next_pixel_time": None
        }
        save_data()
        del active_tokens[comment]
        print(f"[Server] {username} verified session {session_id}")

        await broadcast({
            "type": "verified",
            "session": session_id,
            "username": username
        })

# --- MAIN ---
async def main():
    load_data()
    print(f"Server running on port {PORT}")
    asyncio.create_task(replenish_pixels_task())
    asyncio.create_task(client.start())
    await websockets.serve(ws_handler, "0.0.0.0", PORT)
    await asyncio.Future()

if __name__ == "__main__":
    asyncio.run(main())
