<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>TikTok Live R/Place</title>
<link rel="stylesheet" href="styles.css">
<style>
/* Extra styles for hover UI */
#userHoverInfo {
  display: none;
  position: absolute;
  top: 50px;
  left: 20px;
  background: #222;
  border: 1px solid #555;
  padding: 10px;
  border-radius: 6px;
  text-align: center;
  width: 140px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.6);
  z-index: 1000;
}
#userHoverInfo {
  display: none;
  position: absolute;
  width: 140px;
  height: 100px; /* fixed height */
  background: #222;
  border: 1px solid #555;
  padding: 10px;
  border-radius: 6px;
  text-align: center;
  box-shadow: 0 4px 10px rgba(0,0,0,0.6);
  z-index: 1000;
  overflow: hidden; /* prevent stretching children */
}

#userHoverInfo img {
  width: 64px;
  height: 64px;
  border-radius: 50%;
  object-fit: cover;
  border: 2px solid #4ce0ff;
  display: block;
  margin: 0 auto 6px auto;
}

#hoverTooltip {
  display: none;
  position: absolute;
  background: rgba(0,0,0,0.8);
  color: #fff;
  font-size: 12px;
  padding: 4px 6px;
  border-radius: 4px;
  pointer-events: none;
  z-index: 1000;
}
</style>
</head>
<body>
<h2>TikTok Live R/Place</h2>

<div>
  <button id="getTokenBtn">Generate Verification Token</button>
</div>
<div>
  <label>Verification Token (copy to TikTok chat):</label>
  <input type="text" id="verificationToken" readonly style="width:300px;">
</div>
<div>
  <label>Return Token (save this for login):</label>
  <input type="text" id="returnToken" readonly style="width:300px;">
</div>
<div>
  <input type="text" id="usernameInput" placeholder="TikTok Username">
  <input type="text" id="returnCodeInput" placeholder="Return Token">
  <button id="returnLoginBtn">Return Login</button>
</div>

<div id="status">Not verified</div>
<div id="userInfo"></div>

<div id="mainLayout">
  <div id="palette-panel">
    <h3>ðŸŽ¨ Color Palette</h3>
    <div class="colors" id="colorPalette">
      <div class="color selected" data-color="#4ce0ff" style="background:#4ce0ff;"></div>
      <div class="color" data-color="#ff0000" style="background:#ff0000;"></div>
      <div class="color" data-color="#00ff00" style="background:#00ff00;"></div>
      <div class="color" data-color="#0000ff" style="background:#0000ff;"></div>
      <div class="color" data-color="#ffff00" style="background:#ffff00;"></div>
      <div class="color" data-color="#ff00ff" style="background:#ff00ff;"></div>
      <div class="color" data-color="#00ffff" style="background:#00ffff;"></div>
      <div class="color" data-color="#ffffff" style="background:#ffffff; border:1px solid #ccc;"></div>
    </div>
  </div>
</div>

<!-- Hover UI -->
<div id="userHoverInfo">
  <img id="hoverPfp" src="default.png" alt="profile" />
  <div id="hoverName"></div>
</div>
<div id="hoverTooltip"></div>

<div id="canvasContainer">
  <canvas id="canvas"></canvas>
</div>

<div>
  <button id="adminLoginBtn">Admin Login</button>
</div>
<div id="adminPanel">
  <input type="text" id="adminKeyInput" placeholder="Admin Key">
  <button id="adminVerifyBtn">Verify Admin</button>
  <div id="adminControls" style="display:none;">
    <input type="text" id="adminUsername" placeholder="Username">
    <button id="clearUserPixelsBtn">Clear User Pixels</button>
    <button id="unverifyUserBtn">Unverify User</button>
    <button id="clearAllBtn">Clear All Pixels</button>
  </div>
</div>

<script>
const currentSession = 'session_' + Math.random().toString(36).substring(2, 10);
const ws = new WebSocket("wss://tiktokliveweb-production.up.railway.app");

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const gridSize = 1000;
const pixels = {}; // index -> {color, user, pfp}
canvas.width = canvas.clientWidth;
canvas.height = canvas.clientHeight;

let scale, minScale, offsetX, offsetY;
let dragging=false, lastX=0, lastY=0;

let verified=false;
let username=null;
let pixelsLeft=0;
let nextPixelTime=null;
let returnToken=null;
let verificationToken=null;
let activeColor = "#4ce0ff";

// Hover UI elements
const hoverInfo = document.getElementById("userHoverInfo");
const hoverName = document.getElementById("hoverName");
const hoverPfp = document.getElementById("hoverPfp");
const tooltip = document.getElementById("hoverTooltip");

// --- Canvas view ---
function resetView(){
  minScale = Math.min(canvas.width/gridSize, canvas.height/gridSize);
  scale = minScale;
  offsetX = (canvas.width - gridSize*scale)/2;
  offsetY = (canvas.height - gridSize*scale)/2;
}
resetView();

function clampOffsets(){
  const maxOffsetX = 0, maxOffsetY=0;
  const minOffsetX = canvas.width - gridSize*scale, minOffsetY = canvas.height - gridSize*scale;
  if(offsetX>maxOffsetX) offsetX=maxOffsetX;
  if(offsetY>maxOffsetY) offsetY=maxOffsetY;
  if(offsetX<minOffsetX) offsetX=minOffsetX;
  if(offsetY<minOffsetY) offsetY=minOffsetY;
}

function drawBoard(){
  ctx.setTransform(scale,0,0,scale,offsetX,offsetY);
  ctx.clearRect(-offsetX/scale,-offsetY/scale,canvas.width/scale,canvas.height/scale);
  ctx.fillStyle="#222"; ctx.fillRect(0,0,gridSize,gridSize);
  if(scale>4){
    ctx.strokeStyle="#333"; ctx.lineWidth=0.05;
    for(let x=0;x<gridSize;x++){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,gridSize);ctx.stroke();}
    for(let y=0;y<gridSize;y++){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(gridSize,y);ctx.stroke();}
  }
  for(const idx in pixels){
    const {color} = pixels[idx];
    const x=idx%gridSize, y=Math.floor(idx/gridSize);
    ctx.fillStyle=color;
    ctx.fillRect(x,y,1,1);
  }
}

canvas.addEventListener("wheel", e=>{
  e.preventDefault();
  const mouseX=(e.offsetX-offsetX)/scale;
  const mouseY=(e.offsetY-offsetY)/scale;
  const zoom=e.deltaY<0?1.1:0.9;
  scale*=zoom;
  scale=Math.min(Math.max(scale,minScale),40);
  offsetX=e.offsetX - mouseX*scale;
  offsetY=e.offsetY - mouseY*scale;
  clampOffsets();
  drawBoard();
});

// --- Hover with TikTok avatar fix ---
function getTikTokAvatar(username){
  return `https://www.tiktok.com/@${username}/avatar`;
}

canvas.addEventListener("mousemove", (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = Math.floor((e.clientX - rect.left - offsetX) / scale);
  const y = Math.floor((e.clientY - rect.top - offsetY) / scale);

  if (x<0 || y<0 || x>=gridSize || y>=gridSize) {
    tooltip.style.display = "none";
    hoverInfo.style.display = "none";
    return;
  }

  const index = y * gridSize + x;
  const pixel = pixels[index];

  if (pixel && pixel.user) {
    tooltip.style.left = e.pageX + 10 + "px";
    tooltip.style.top = e.pageY + 10 + "px";
    tooltip.textContent = pixel.user;
    tooltip.style.display = "block";

    hoverInfo.style.left = e.pageX + 10 + "px";
    hoverInfo.style.top = e.pageY + 30 + "px";
    hoverInfo.style.display = "block";
    hoverName.textContent = pixel.user;

    // Use server pfp or TikTok avatar
    const avatarUrl = pixel.pfp || getTikTokAvatar(pixel.user);
    hoverPfp.src = avatarUrl;
    hoverPfp.style.width = "64px";
    hoverPfp.style.height = "64px";
    hoverPfp.style.objectFit = "cover";
    hoverPfp.style.borderRadius = "50%";
  } else {
    tooltip.style.display = "none";
    hoverInfo.style.display = "none";
  }
});

canvas.addEventListener("mousedown", e=>{
  if(e.button===0){ lastX=e.clientX; lastY=e.clientY; dragging=false; }
});
canvas.addEventListener("mouseup", e=>{
  if(!dragging){
    if(!verified){ alert("Not verified!"); return; }
    if(pixelsLeft<=0){ alert("No pixels available!"); return; }
    const x=Math.floor((e.offsetX-offsetX)/scale);
    const y=Math.floor((e.offsetY-offsetY)/scale);
    if(x>=0 && y>=0 && x<gridSize && y<gridSize){
      ws.send(JSON.stringify({
        action:"place_pixel",
        session:currentSession,
        index:x+y*gridSize,
        color:activeColor
      }));
    }
  }
  dragging=false;
});

// --- Color selection ---
document.querySelectorAll("#colorPalette .color").forEach(c=>{
  c.addEventListener("click", ()=>{
    document.querySelectorAll("#colorPalette .color").forEach(cl=>cl.classList.remove("selected"));
    c.classList.add("selected");
    activeColor = c.getAttribute("data-color");
  });
});

// --- WebSocket ---
ws.onopen = ()=> console.log("âœ… WS connected!");
ws.onmessage = e=>{
  const msg = JSON.parse(e.data);
  if(msg.type==="init_pixels"){
    for(const idx in msg.pixels){ pixels[idx] = msg.pixels[idx]; }
    drawBoard();
  }
  else if(msg.type==="token"){
    verificationToken=msg.token; returnToken=msg.return_token;
    document.getElementById("verificationToken").value=verificationToken;
    document.getElementById("returnToken").value=returnToken;
    document.getElementById("status").textContent="Type verification token in TikTok chat!";
  }
  else if(msg.type==="verified"){
    if(msg.session===currentSession){
      verified=true; username=msg.username;
      pixelsLeft=msg.pixels_left ?? 1;
      nextPixelTime=msg.next_pixel_time ?? (Date.now()/1000+5);
      returnToken=msg.return_token ?? returnToken;
      document.getElementById("status").textContent=`VERIFIED! Welcome ${username}`;
      document.getElementById("returnToken").value=returnToken;
      document.getElementById("palette-panel").style.display="block";
    }
  }
  else if(msg.type==="pixel"){
    pixels[msg.index]={color:msg.color,user:msg.user,pfp:msg.pfp};
    if(msg.session===currentSession){
      pixelsLeft=Math.max(0,pixelsLeft-1);
      nextPixelTime=Date.now()/1000+5;
    }
    drawBoard();
  }
  else if(msg.type==="clear_user" || msg.type === "clear_all"){
    const removed=msg.sessionMap;
    for(const idx in removed){ delete pixels[Number(idx)]; }
    drawBoard();
  }
  else if(msg.type==="error"){
    if(msg.session===undefined || msg.session===currentSession)
      alert(msg.message);
  }
};

// --- Generate token ---
document.getElementById("getTokenBtn").addEventListener("click", ()=>{
  ws.send(JSON.stringify({action:"get_token", session:currentSession}));
});

// --- Return login ---
document.getElementById("returnLoginBtn").addEventListener("click", ()=>{
  const uname=document.getElementById("usernameInput").value.trim();
  const rtoken=document.getElementById("returnCodeInput").value.trim();
  if(!uname||!rtoken) return alert("Enter username and return token");
  ws.send(JSON.stringify({action:"verify", username:uname, token:rtoken, session:currentSession}));
});

drawBoard();
</script>
</body>
</html>
