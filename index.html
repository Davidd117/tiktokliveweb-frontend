<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>TikTok Live R/Place</title>
<style>
body { background:#111; color:white; text-align:center; font-family:Arial; }
#canvasContainer { width: 800px; height: 800px; margin: 20px auto; border: 2px solid #444; background: #222; overflow: hidden; cursor: grab; }
canvas { width:100%; height:100%; display:block; }
input, button { padding:5px; margin:5px; }
#userInfo { margin-top: 10px; }
</style>
</head>
<body>
<h2>TikTok Live R/Place</h2>

<div>
  <button id="getTokenBtn">Generate Verification Token</button>
</div>
<div id="tokenDisplay">Token will appear here</div>
<div id="status">Not verified</div>
<div id="userInfo"></div>

<div id="canvasContainer">
  <canvas id="canvas"></canvas>
</div>

<script>
const currentUser = 'session_' + Math.random().toString(36).substring(2, 10);
const ws = new WebSocket("wss://tiktokliveweb-production.up.railway.app");

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const gridSize = 1000;
const pixels = new Uint8Array(gridSize*gridSize);
canvas.width = canvas.clientWidth;
canvas.height = canvas.clientHeight;

let scale, minScale, offsetX, offsetY;
let dragging=false, lastX, lastY, mouseDownX, mouseDownY;
let verified=false, pixelsLeft=0, nextPixelTime=null;
let countdownInterval=null;

function resetView(){
    minScale = Math.min(canvas.width/gridSize, canvas.height/gridSize);
    scale = minScale;
    offsetX = (canvas.width - gridSize*scale)/2;
    offsetY = (canvas.height - gridSize*scale)/2;
}
resetView();

function clampOffsets(){
    const maxOffsetX = 0, maxOffsetY=0;
    const minOffsetX = canvas.width - gridSize*scale, minOffsetY = canvas.height - gridSize*scale;
    if(offsetX>maxOffsetX) offsetX=maxOffsetX;
    if(offsetY>maxOffsetY) offsetY=maxOffsetY;
    if(offsetX<minOffsetX) offsetX=minOffsetX;
    if(offsetY<minOffsetY) offsetY=minOffsetY;
}

function drawBoard(){
    ctx.setTransform(scale,0,0,scale,offsetX,offsetY);
    ctx.clearRect(-offsetX/scale,-offsetY/scale,canvas.width/scale,canvas.height/scale);
    ctx.fillStyle="#222"; ctx.fillRect(0,0,gridSize,gridSize);
    if(scale>4){
        ctx.strokeStyle="#333"; ctx.lineWidth=0.05;
        for(let x=0;x<gridSize;x++){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,gridSize);ctx.stroke();}
        for(let y=0;y<gridSize;y++){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(gridSize,y);ctx.stroke();}
    }
    for(let i=0;i<pixels.length;i++){
        if(pixels[i]){
            const x=i%gridSize, y=Math.floor(i/gridSize);
            ctx.fillStyle="#4ce0ff";
            ctx.fillRect(x,y,1,1);
        }
    }
}

// --- Zoom & Pan ---
canvas.addEventListener("wheel", e=>{
    e.preventDefault();
    const mouseX=(e.offsetX-offsetX)/scale;
    const mouseY=(e.offsetY-offsetY)/scale;
    const zoom=e.deltaY<0?1.1:0.9;
    scale*=zoom;
    scale=Math.min(Math.max(scale,minScale),40);
    offsetX=e.offsetX - mouseX*scale;
    offsetY=e.offsetY - mouseY*scale;
    clampOffsets();
    drawBoard();
});

canvas.addEventListener("mousedown", e=>{
    if(e.button===0){
        dragging=false;
        mouseDownX=e.clientX;
        mouseDownY=e.clientY;
        lastX=e.clientX;
        lastY=e.clientY;
    }
});

canvas.addEventListener("mousemove", e=>{
    const dx = e.clientX - mouseDownX;
    const dy = e.clientY - mouseDownY;
    if(!dragging && Math.sqrt(dx*dx + dy*dy) > 3) { // threshold to start drag
        dragging=true;
        canvas.style.cursor="grabbing";
    }
    if(dragging){
        offsetX += e.clientX - lastX;
        offsetY += e.clientY - lastY;
        lastX = e.clientX;
        lastY = e.clientY;
        clampOffsets();
        drawBoard();
    }
});

canvas.addEventListener("mouseup", e=>{
    if(!dragging){ // treat as click
        const x=Math.floor((e.offsetX-offsetX)/scale);
        const y=Math.floor((e.offsetY-offsetY)/scale);
        if(!verified){ alert("You are not verified!"); return; }
        if(pixelsLeft <= 0){ alert("No pixels available! Wait for cooldown."); return; }
        if(x>=0 && y>=0 && x<gridSize && y<gridSize){
            const idx = x+y*gridSize;
            ws.send(JSON.stringify({action:"place_pixel", session:currentUser, index:idx}));
        }
    }
    dragging=false;
    canvas.style.cursor="grab";
});

// --- Update user info display ---
function updateUserInfo(){
    const infoDiv = document.getElementById("userInfo");
    let timeLeft = 0;
    if(nextPixelTime) timeLeft = Math.max(0, Math.floor(nextPixelTime - Date.now()/1000));
    infoDiv.textContent = `User: ${verified ? username : currentUser} | Pixels left: ${pixelsLeft} | Cooldown: ${timeLeft}s`;
}

// --- Countdown timer ---
function startCountdown(){
    if(countdownInterval) clearInterval(countdownInterval);
    countdownInterval=setInterval(()=>{
        if(nextPixelTime && pixelsLeft>=0){
            let remaining = Math.max(0, Math.floor(nextPixelTime - Date.now()/1000));
            if(remaining<=0){
                pixelsLeft+=1;
                nextPixelTime = Date.now()/1000 + 5; // COOLDOWN
                ws.send(JSON.stringify({action:"update_pixels", session:currentUser}));
            }
        }
        updateUserInfo();
    },1000);
}

// --- WebSocket ---
let username="";
ws.onopen = ()=>console.log("âœ… WS connected!");
ws.onmessage = e=>{
    const msg = JSON.parse(e.data);

    if(msg.type==="init_pixels"){
        for(const idx in msg.pixels){ pixels[idx]=1; }
        drawBoard();
    }
    else if(msg.type==="token"){
        document.getElementById("tokenDisplay").textContent="Your token: "+msg.token;
        document.getElementById("status").textContent="Type this token in TikTok Live to verify";
    }
    else if(msg.type==="verified"){
        if(msg.session===currentUser){
            verified=true;
            username=msg.username;
            if(msg.pixels_left!==undefined) pixelsLeft=msg.pixels_left;
            if(msg.next_pixel_time) nextPixelTime=msg.next_pixel_time;
            document.getElementById("status").textContent="Welcome back "+username+"! You can place your pixels.";
            startCountdown();
        }
    }
    else if(msg.type==="pixel"){
        pixels[msg.index]=1;
        if(msg.session === currentUser){
            pixelsLeft = Math.max(0, pixelsLeft-1);
            nextPixelTime = Date.now()/1000 + 5; // COOLDOWN
        }
        drawBoard();
    }
    else if(msg.type==="info"){
        if(msg.session === currentUser){
            if(msg.pixels_left!==undefined) pixelsLeft = msg.pixels_left;
            if(msg.next_pixel_time) nextPixelTime = msg.next_pixel_time;
        }
    }
    else if(msg.type==="error"){
        if(msg.session === undefined || msg.session === currentUser){
            alert(msg.message);
        }
    }
};

// --- Generate token ---
document.getElementById("getTokenBtn").addEventListener("click", ()=>{
    ws.send(JSON.stringify({action:"get_token", session:currentUser}));
});

drawBoard();
</script>
</body>
</html>
