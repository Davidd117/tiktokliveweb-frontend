<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>TikTok Live R/Place</title>
<style>
body { background:#111; color:white; font-family:Arial; text-align:center; margin:0; padding:0; }
#canvasContainer { width:100%; height:80vh; background:#222; overflow:hidden; cursor:grab; position:relative; }
canvas { display:block; width:100%; height:100%; }
input, button { padding:8px 12px; margin:5px; font-size:14px; }
#tokenDisplay, #status, #userInfo { margin:5px; }
</style>
</head>
<body>

<h2>TikTok Live R/Place (1000x1000)</h2>

<div id="login">
  <input type="text" id="usernameInput" placeholder="Enter username">
  <input type="text" id="returnCodeInput" placeholder="Return code">
  <button id="returnLoginBtn">Return Login</button>
  <button id="getTokenBtn">Generate Verification Token</button>
</div>

<div id="tokenDisplay">Token will appear here</div>
<div id="status">Not verified</div>
<div id="userInfo"></div>

<div id="canvasContainer">
  <canvas id="canvas"></canvas>
</div>

<script>
// --- SESSION & WS ---
const session = 'session_' + Math.random().toString(36).substring(2,10);
const ws = new WebSocket("wss://tiktokliveweb-production.up.railway.app");

// --- GRID ---
const GRID_SIZE = 1000;
const pixels = new Uint8Array(GRID_SIZE*GRID_SIZE);

// --- CANVAS ---
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = canvas.clientWidth;
canvas.height = canvas.clientHeight;

let scale, minScale, offsetX, offsetY;
let dragging=false, lastX=0, lastY=0;

// --- USER STATE ---
let verified=false;
let username=null;
let pixelsLeft=0;
let nextPixelTime=null;

// --- VIEW ---
function resetView(){
  minScale = Math.min(canvas.width/GRID_SIZE, canvas.height/GRID_SIZE);
  scale = minScale;
  offsetX = (canvas.width - GRID_SIZE*scale)/2;
  offsetY = (canvas.height - GRID_SIZE*scale)/2;
}
resetView();

function clampOffsets(){
  const maxX=0, maxY=0;
  const minX=canvas.width-GRID_SIZE*scale, minY=canvas.height-GRID_SIZE*scale;
  offsetX=Math.max(Math.min(offsetX,maxX),minX);
  offsetY=Math.max(Math.min(offsetY,maxY),minY);
}

function drawBoard(){
  ctx.setTransform(scale,0,0,scale,offsetX,offsetY);
  ctx.clearRect(-offsetX/scale,-offsetY/scale,canvas.width/scale,canvas.height/scale);
  ctx.fillStyle="#222";
  ctx.fillRect(0,0,GRID_SIZE,GRID_SIZE);

  // Draw pixels
  for(let i=0;i<pixels.length;i++){
    if(pixels[i]){
      const x=i%GRID_SIZE, y=Math.floor(i/GRID_SIZE);
      ctx.fillStyle="#4ce0ff";
      ctx.fillRect(x,y,1,1);
    }
  }

  // Optional grid lines
  if(scale>4){
    ctx.strokeStyle="#333";
    ctx.lineWidth=0.05;
    for(let x=0;x<GRID_SIZE;x++){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,GRID_SIZE);ctx.stroke();}
    for(let y=0;y<GRID_SIZE;y++){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(GRID_SIZE,y);ctx.stroke();}
  }
}

// --- PAN & ZOOM ---
canvas.addEventListener('wheel', e=>{
  e.preventDefault();
  const mx=(e.offsetX-offsetX)/scale;
  const my=(e.offsetY-offsetY)/scale;
  const zoom = e.deltaY<0?1.1:0.9;
  scale*=zoom;
  scale=Math.min(Math.max(scale,minScale),40);
  offsetX=e.offsetX - mx*scale;
  offsetY=e.offsetY - my*scale;
  clampOffsets();
  drawBoard();
});

canvas.addEventListener('mousedown', e=>{
  if(e.button!==0) return;
  lastX=e.clientX; lastY=e.clientY; dragging=false;
});

canvas.addEventListener('mousemove', e=>{
  if(e.buttons!==1) return;
  const dx=e.clientX-lastX, dy=e.clientY-lastY;
  if(Math.abs(dx)>2 || Math.abs(dy)>2) dragging=true;
  if(dragging){
    offsetX+=dx; offsetY+=dy;
    lastX=e.clientX; lastY=e.clientY;
    clampOffsets();
    drawBoard();
  }
});

canvas.addEventListener('mouseup', e=>{
  if(!dragging){
    if(!verified){ alert("You are not verified!"); return; }
    if(pixelsLeft<=0){ alert("No pixels left! Wait for cooldown."); return; }
    const x=Math.floor((e.offsetX-offsetX)/scale);
    const y=Math.floor((e.offsetY-offsetY)/scale);
    if(x>=0 && y>=0 && x<GRID_SIZE && y<GRID_SIZE){
      ws.send(JSON.stringify({action:"place_pixel", session, index:x+y*GRID_SIZE}));
    }
  }
  dragging=false;
});

// --- UPDATE USER INFO ---
function updateUserInfo(){
  const infoDiv=document.getElementById('userInfo');
  let timeLeft=0;
  if(nextPixelTime) timeLeft=Math.max(0,Math.floor(nextPixelTime-Date.now()/1000));
  infoDiv.textContent = username?
    `User: ${username} | Pixels left: ${pixelsLeft} | Cooldown: ${timeLeft}s`
    : 'Not verified';
}

// Countdown timer
setInterval(()=>{
  if(!verified || !nextPixelTime) return;
  const now=Date.now()/1000;
  if(now>=nextPixelTime){
    pixelsLeft++;
    nextPixelTime=now+5; // server cooldown
  }
  updateUserInfo();
},1000);

// --- WEBSOCKET ---
ws.onopen = ()=>console.log("âœ… WS connected");

ws.onmessage = e=>{
  const msg = JSON.parse(e.data);

  if(msg.type==="init_pixels"){
    for(const idx in msg.pixels) pixels[idx]=1;
    drawBoard();
  }
  else if(msg.type==="token"){
    document.getElementById("tokenDisplay").textContent = "Your token: "+msg.token;
    document.getElementById("status").textContent = "Type this token in TikTok Live chat to verify";
  }
  else if(msg.type==="verified"){
    if(msg.session===session){
      verified=true;
      username=msg.username;
      pixelsLeft=msg.pixels_left ?? 1;
      nextPixelTime=msg.next_pixel_time ?? (Date.now()/1000+5);
      document.getElementById("status").textContent=`VERIFIED! Welcome ${username}`;
    }
  }
  else if(msg.type==="pixel"){
    pixels[msg.index]=1;
    if(msg.session===session){
      pixelsLeft=Math.max(0,pixelsLeft-1);
      nextPixelTime=Date.now()/1000+5;
    }
    drawBoard();
  }
  else if(msg.type==="info"){
    if(msg.session===session){
      pixelsLeft=msg.pixels_left;
      nextPixelTime=msg.next_pixel_time ?? (Date.now()/1000+5);
    }
  }
  else if(msg.type==="error"){
    if(msg.session===undefined || msg.session===session){
      alert(msg.message);
    }
  }
};

// --- BUTTONS ---
// Generate TikTok token
document.getElementById('getTokenBtn').addEventListener('click', ()=>{
  ws.send(JSON.stringify({action:"get_token", session}));
});

// Return login
document.getElementById('returnLoginBtn').addEventListener('click', ()=>{
  const userInput=document.getElementById('usernameInput').value.trim();
  const returnCode=document.getElementById('returnCodeInput').value.trim();
  if(!userInput || !returnCode){ alert("Enter username and return code"); return; }
  ws.send(JSON.stringify({
    action:"return_login",
    session,
    username:userInput,
    return_code:returnCode
  }));
});

drawBoard();
</script>
</body>
</html>
